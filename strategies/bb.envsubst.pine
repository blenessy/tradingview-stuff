//@version=5
strategy(shorttitle=$SHORT_TITLE, title=$TITLE, overlay=true, pyramiding=$PYRAMIDING, initial_capital=$INITIAL_CAPITAL, commission_value=$COMMISSION_PERCENT, default_qty_type=$QTY_TYPE, default_qty_value=$QTY_VALUE)

// Group names
lbgrp = "Lower Band - Buy"
ubgrp = "Upper Band - Sell"

// General Inputs
devMode = input.bool($DEV_MODE, "Development mode")
if not devMode and timeframe.period != $CHART_TIMEFRAME
    runtime.error("expecting chart timeframe: " + $CHART_TIMEFRAME)
if not devMode and syminfo.tickerid != $CHART_TICKERID
    runtime.error("expecting tickerid: " + $CHART_TICKERID)
backtestStart = input.time(timestamp($BACKTEST_START), "Backtest start")
rebuyResistance = input.float($PYRAMIDING_REBUY_RESISTANCE, 'Rebuy resistance', minval=.01, step=.01)
maxProfitablePositions = input.int($PYRAMIDING_MAX_PROFIT_POSITIONS, 'Max profitable positions', minval=1)

// BB Lower Band configuration
lbMAType = input.string($LB_MA_TYPE, 'Moving average', inline='lbma1', group=lbgrp,
     options=["ALMA", 'EMA', 'SMA', 'WMA', 'VWMA', 'RMA', 'HMA', 'VAMA'])
lbMALen = input.int($LB_MA_LENGTH, 'MA length', minval=3, inline='lbma1', group=lbgrp)
lbMASource = input.source($LB_MA_SOURCE, "MA source", group=lbgrp)

lbAlmaOffset = input.float($LB_ALMA_OFFSET, "ALMA offset", step=.01, minval=.01, inline='lbalma', group=lbgrp)
lbAlmaSigma = input.float($LB_ALMA_SIGMA, "ALMA sigma", step=.1, minval=.1, inline='lbalma', group=lbgrp)

lbVamaFastLen = input.int($LB_VAMA_FAST_LENGTH, "VAMA fast length", minval=2, inline='lbvama', group=lbgrp)
lbVamaWeight = input.float($LB_VAMA_WEIGHT, "VAMA weight", step=.01, minval=.01, inline='lbvama', group=lbgrp)

lbDevType = input.string($LB_DEV_TYPE, 'Deviation', options=['STD', 'MEAN'], inline="lbdev1", group=lbgrp)
lbDevLen = input.int($LB_DEV_LENGTH, 'Dev. length', minval=3, inline="lbdev1", group=lbgrp)
lbDevSource = input.source($LB_DEV_SOURCE, "Dev. source", inline="lbdev2", group=lbgrp)
lbDevScale =  input.float($LB_DEV_SCALE, 'Dev. scale factor', minval=.01, maxval=50, step=.05, inline="lbdev2", group=lbgrp)

lbLongSource = input.source($LB_LONG_SOURCE, "Buy source", inline='long1', group=lbgrp)
lbLongStrategy = input.string($LB_LONG_STRATEGY, 'Strategy', inline='long1', group=lbgrp,
     options=['Price x-over MA', 'Price x-under MA', 'Price < MA'])

// BB Upper Band configuration
ubMAType = input.string($UB_MA_TYPE, 'Moving average', inline='ubma1', group=ubgrp,
     options=["ALMA", 'EMA', 'SMA', 'WMA', 'VWMA', 'RMA', 'HMA', 'VAMA'])
ubMALen = input.int($UB_MA_LENGTH, 'MA length', minval=3, inline='ubma1', group=ubgrp)
ubMASource = input.source($UB_MA_SOURCE, "MA source", group=ubgrp)

ubAlmaOffset = input.float($UB_ALMA_OFFSET, "ALMA offset", step=.01, minval=.01, inline='ubalma', group=ubgrp)
ubAlmaSigma = input.float($UB_ALMA_SIGMA, "ALMA sigma", step=.1, minval=.1, inline='ubalma', group=ubgrp)

ubVamaFastLen = input.int($UB_VAMA_FAST_LENGTH, "VAMA fast length", minval=2, inline='ubvama', group=ubgrp)
ubVamaWeight = input.float($UB_VAMA_WEIGHT, "VAMA weight", step=.01, minval=.01, inline='ubvama', group=ubgrp)

ubDevType = input.string($UB_DEV_TYPE, 'Deviation', options=['STD', 'MEAN'], inline="ubdev1", group=ubgrp)
ubDevLen = input.int($UB_DEV_LENGTH, 'Dev. length', minval=3, inline="ubdev1", group=ubgrp)
ubDevSource = input.source($UB_DEV_SOURCE, "Dev. source", inline="ubdev2", group=ubgrp)
ubDevScale =  input.float($UB_DEV_SCALE, 'Dev. scale factor', minval=.01, maxval=50, step=.05, inline="ubdev2", group=ubgrp)

ubShortSource = input.source($UB_SHORT_SOURCE, "Sell source", inline='short1', group=ubgrp)
ubShortStrategy = input.string($UB_SHORT_STRATEGY, 'Strategy', inline='short1', group=ubgrp,
     options=['Price x-over MA', 'Price x-under MA', 'Price > MA'])

// https://medium.com/the-investors-handbook/a-new-variation-on-the-bollinger-bands-in-python-7f6d91f02c5e
vama(src, dev1Len, dev2Len, scale) =>
    longStdDev = ta.stdev(src, dev2Len >= dev1Len ? dev2Len : dev1Len)
    shortStdDev = ta.stdev(src, dev2Len >= dev1Len ? dev1Len : dev2Len)
    alpha = shortStdDev / longStdDev * scale
    ma = float(na)
    ma := alpha * src + (1 - alpha) * nz(ma[1])

movingAverage(type, src, length) =>
    switch type
        "EMA" => ta.ema(src, length)
        "HMA" => ta.ema(src, length)
        "RMA" => ta.rma(src, length)
        "SMA" => ta.sma(src, length)
        "VWMA" => ta.vwma(src, length)
        "WMA" => ta.wma(src, length)
        => float(na)

deviation(type, src, length) =>
    switch type
        "STD" => ta.stdev(src, length)
        "MEAN" => ta.dev(src, length)
        => float(na)

compareSources(type, sigsrc, masrc) =>
    switch type
        "Price > MA" => sigsrc > masrc
        "Price < MA" => sigsrc < masrc
        "Price x-over MA" => ta.crossover(sigsrc, masrc)
        "Price x-under MA" => ta.crossunder(sigsrc, masrc)
        => bool(na)


// Lower Band Calculation
lbMovingAverage = switch lbMAType
    "ALMA" => ta.alma(lbMASource, lbMALen, lbAlmaOffset, lbAlmaSigma)
    "VAMA" => vama(lbMASource, lbMALen, lbVamaFastLen, lbVamaWeight)
    => movingAverage(lbMAType, lbMASource, lbMALen)
lowerBand = lbMovingAverage - deviation(lbDevType, lbDevSource, lbDevLen) * lbDevScale

// Upper Band Calculation
ubMovingAverage = switch ubMAType
    "ALMA" => ta.alma(ubMASource, ubMALen, ubAlmaOffset, ubAlmaSigma)
    "VAMA" => vama(ubMASource, ubMALen, ubVamaFastLen, ubVamaWeight)
    => movingAverage(ubMAType, ubMASource, ubMALen)
upperBand = ubMovingAverage + deviation(ubDevType, ubDevSource, ubDevLen) * ubDevScale

// Color Palette
colorBandLine = color.new(color.gray, 0)
colorTradeZone = color.new(color.teal, 70)
p1 = plot(upperBand, 'BB Upper', color=colorBandLine)
p2 = plot(lowerBand, 'BB Lower', color=colorBandLine)
fill(p1, p2, color=color.new(color.gray, 80))
p3 = plot(lbLongSource, 'Buy', color=colorTradeZone)
p4 = plot(ubShortSource, 'Sell', color=colorTradeZone)
fill(p3, p4, color=colorTradeZone)

// isBuyEvent/isSellEvent is used to prevent re-triggering of alerts
shouldBuy = compareSources(lbLongStrategy, lbLongSource, lowerBand)
shouldSell = strategy.opentrades > maxProfitablePositions and close >= strategy.position_avg_price
shouldClose = compareSources(ubShortStrategy, ubShortSource, upperBand)

// Make sure consecutive buys/sells improve the average position price
okOpenLong = na(strategy.position_avg_price) or strategy.position_avg_price >= (lbLongSource * rebuyResistance)

// Entry & Exit
for i = maxProfitablePositions + 1 to strategy.opentrades by 1
    strategy.close("position " + str.tostring(i), when=shouldSell)
strategy.close_all(when=shouldClose)
strategy.entry("position " + str.tostring(strategy.opentrades + 1), strategy.long, when=time > backtestStart and okOpenLong and shouldBuy)
